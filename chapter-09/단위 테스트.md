# 단위 테스트

### TDD 법칙 세 가지
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다

#### 테스트는 유연성, 유지보수성, 재사용성을 제공한다
- 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트이다
    - 코드 변경이 자유롭다 
    - 테스트 케이스가 없다면 모든 변경이 잠정적인 버그이다

### 깨끗한 테스트 코드
- BUILD-OPERATE-CHECK
    - `BUILD` : 테스트 자료를 만든다
    - `OPERATE` : 테스트 자료를 조작한다
    - `CHECK` : 조작한 결과가 올바른지 확인한다
- 잡다하고 세세한 코드는 테스트 코드에서 제외할 수 있도록 한다
- 본론에 돌입해 진짜 필요한 자료 유형과 함수만 사용


이상적인 테스트 코드 예시
```java
@Test
public void turnOnCoolerAndBlowerIfTooHot() {
    tooHot();

    assertEquals("hBchl", hw.getState());
}

```

#### 테스트 당 assert 하나
- JUnit으로 테스트 코드를 짤 때는 함수마다 assert 문을 하나만 사용하기를 권장
- 결론이 하나이기 때문에 코드를 이해하기 쉽고 빠르다
- `예시` : assert 문을 하나로 병합하는 방식이 불합리 해보인다면?
    - 테스트를 두 개로 쪼개 각자가 assert를 수행

#### `given-when-then` 관례를 사용해 가독성을 높인다

#### Template Method 패턴
- `given-when-then` 관례의 `given-when` 부분이 중복된다고 느낀다면?
    - `given-when` 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두면 된다
    - 또는 완전히 독자적인 테스트 클래스를 만들어 `@Before` 함수에 `given-when` 부분을 넣고 `@Test` 함수에 `then` 부분을 넣는다

> 배보다 배꼽이 더 크다고 생각이 들 수도 있다. 이것 저걱 감안해본다면 assert를 여럿 사용하는 편이 더 좋을지도
> -> 결국 취향 차이인것 같다

### 테스트 당 개념 하나
- 한 테스트에 assert를 여러 번 사용하더라도, 이것저것 잡다한 개념을 연속으로 테스트는 하지 말자
- 독자적인 개념은 독자적인 테스트 하나로 쪼갤 것

<br>

### F.I.R.S.T
깨끗한 테스트가 따르는 5가지 규칙
- Fast
    - 테스트가 빠르게 돌지 않으면 자주 돌릴 엄두를 내지 못하고 결국 코드 품질이 망가지기 마련
- Independent
    - 각 테스트는 서로 의존하면 안 된다
    - 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안된다
    - 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다
- Repeatable
    - 실제 환경, QA 환경, 다양한 환경에서 실행할 수 있어야 한다
    - 테스트가 돌아가지 않는 환경이 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다
    - 환경에 의해 테스트를 수행하지 못하는 상황에 직면한다
- Self-Validating
    - 테스트는 boolean 값으로 결과를 내야 한다
    - 성공 or 실패
    - 통과 여부를 위해 텍스트 파일 두 개를 수작업으로 비교하게 만들어서도 안 된다 -> 판단이 주관적이 되며 지루한 수작업 평가가 필요하게 되므로
- Timely
    - 단위 테스트는 실제 코드를 구현하기 직전에 구현할 것
    - 구현 후 테스트를 작성하면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다
    


