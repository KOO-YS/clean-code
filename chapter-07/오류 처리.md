# 오류 처리

### 오류 코드보다 예외를 사용하라
- 과거 예외를 지원하지 않는 언어는 오류를 처리하고 보고하는 방법이 제한적이었다
  - 오류 플래그를 설정하거나 호출자에게 오류 코드를 반환
- 오류가 발생하면 예외를 던지는 편이 낫다

### Try-Catch-Finally 문부터 작성하라
- try-catch-finally 문에서 try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어갈 수 있다

### 미확인(unchecked) 예외를 사용하라
**확인된 예외**
- 확인된 예외가 치르는 비용에 상응하는 이익을 제공하는지 따져봐야 한다
  - C#, C++, Python, Ruby 등 여러 언어가 확인된 예외를 징뤈하지 않더라도, 안정적인 소프트웨어를 구현하기에 무리가 없다
- 확인된 예외는 OCP(Open Closed Principle)을 위반한다
  - 메소드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메소드 모두가 선언부에 해당 예외를 정의해야 한다
  - 모듈과 관련된 코드가 전혀 바뀌지 않았더라도 하위 단계에서 코드가 변경되면 상위 단계 메소드 선언부를 전부 고쳐야 한다 
- 때로는 확인된 예외가 유용할 수 있다 -> 아주 중요한 라이브러리를 작성하여 모든 예외를 잡아야 할 때 

### 예외에 의미를 제공하라
- 예외를 던질 때는 전후 상황을 충분히 덧붙인다
- 오류가 발생한 원인과 위치를 찾기 쉬워진다
- 자바는 모든 예외에 호출 스택을 제공하고, 실패한 코드의 의도를 파악하려면 오류 메시지에 정보를 담아 예외와 함께 던진다
- 실패한 연산 이름과 실패 유형도 언급 

### 호출자를 고려해 예외 클래스를 정의
- 오류를 분류하는 방법
  - 오류가 발생한 위치로 분류
  - 오류가 발생한 컴포넌트로 분류
  - 유형으로 분류
- 애플리케이션에서 오류를 정의할 떄 프로그래머에게 가장 중요한 관심사 : "오류를 잡아내는 방법"

### null을 반환하지 마라
**오류를 유발하는 행위**
- null을 반환하는 습관 : null 반환은 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다
```java
List<Employee> employees = getEmployees();
if (employee != null) {  
    for (Employee e : employees) {
      totalPay += e.getPay();
    }
}
```
- null 체크하는 대신 `getEmployees()` 메소드를 변경하길 추천
```java
public List<Employee> getEmployees() {
  if ( .. 조건 .. ) {
    return Collections.emptyList();
  }
}
```
- 조건에 맞춰 미리 정의된 읽기 전용 리스트를 반환하면 된다
  - 코드가 깔끔해질뿐더러 NullPointException이 발생할 가능성도 줄어든다

### null을 전달하지 마라
- 정상적인 인수 대신 null을 기대하는 API가 아니라면 메소드로 null을 전달하는 코드는 최대한 피한다

<br>

---


<br>

> 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다
> 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 ?
>
> 튼튼하고 깨끗한 코드를 작성할 수 있다.
> 독립적인 추론이 가능해지며 코드 유지보수성이 크게 높아진다

