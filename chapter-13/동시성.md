# 동시성
동시성과 깔끔한 코드는 양립하기 어렵다

### 동시성이 필요한 이유?
- 동시성은 결합(coupling)을 없애는 전략
    - 무엇(what)과 언제(when)을 분리하는 전략

### 동시성 방어 원칙
- 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술
- 단일 책임 원칙 (SRP : Single Responsibility Principle)
    - 주어진 메소드, 클래스, 컴포넌트를 변경할 이유가 하나뿐이어야 한다는 원칙
    - 복잡성 하나만으로도 따로 분리할 이유가 충분
- 자료범위 제한
    - 객체 하나를 공유한 후 동일 필드를 수정하던 두 스레드가 서로 간섭하므로 예상치 못한 결과를 낳는다
    - 코드 내 임계영역 (critical section)를 `synchronized` 키워드로 보호
    - 임계영역 수를 줄이고 자료를 캡슐화 할 수 있도록 해라
- 자료의 복제
    - 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 가장 좋다
    - 객체를 복제해 읽기 전용으로 사용하거나, 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법 등.. 
    - 사본으로 동기화를 피하면 `내부 잠금을 없애 절약한 시간` == `사본 생성 & 가비지 컬렉션 부하` 로 상쇄될 가능성
- 스레드는 가능한 독립적으로 구현하라
    - 다른 스레드와 자료를 공유하지 않으며 각 스레드는 클라이언트 요청 하나를 처리

### 라이브러리를 이해하라
동시성 측면에서 이전 버전보다 많이 나아진 자바 5, 자바 5로 스레드 코드를 구현한다면 고려해야 할 점
- 스레드 환경에 안전한 컬렉션을 사용 -> 자바 5부터
- 서로 무관한 작업을 수행할 때는 executor 프레임워크 사용
- 가능하다면 스레드가 blocking 되지 않는 방법을 사용
- 일부 클래스 라이브러리는 스레드에 안전하지 못하다

<br>

#### 스레드 환경에 안전한 컬렉션
- `java.util.concurrent` 패키지
    - `ConcurrentHashMap`은 거의 모든 상황에서 HashMap보다 빠르다
        - 동시 읽기/쓰기를 지원
        - 자주 사용하는 복합 연산(->다중 스레드 환경에서 문제가 자주 생기는 연산)을 다중 스레드 상에서 안전하게 만든 메소드로 제공

#### 실행 모델을 이해하라
**다중 스레드 기본 용어**
- 한정된 자원 (Bound Resource)
    - 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적 (ex) DB 연결, 길이가 일정한 읽기/쓰기 버퍼
- 상호 배제 (Mutual Exclusion)
    - 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 지칭
- 기아 (Starving)
    - 스레드가 굉장히 오랫동안 자원을 기다린다
- 데드락 (Deadlock)
    - 여러 스레드가 서로가 끝나기를 기다린다
    - 모든 스레드가 각기 필요한 자원을 다른 스레드가 각자 점유하는 바람에 어느쪽도 더 이상 진행하지 못한다
- 라이브락 (Livelock)
    - 락을 거는 단계에서 각 스레드가 서로를 방해
    - 스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다


### 다중 스레드 프로그래밍에서 사용하는 실행 모델 종류
#### 생산자와 소비자 (Producer-Consumer)
- 하나 이상 **"생산자"** 스레드가 정보를 생성해 버퍼나 대기열에 넣는다 
- 하나 이상 **소비자** 스레드가 대기열에 정보를 가져와 사용
- 생산자 스레드, 소비자 스레드가 사용하는 대기열은 한정된 자원
- 생산자 스레드 -> 대기열에 빈 공간이 있어야 정보를 채우고, 빈 공간이 생길 때까지 기다린다
- 소비자 스레드 -> 대기열에 정보가 있어야 가져오고, 정보가 채워질 때까지 기다린다
- 이 둘은 서로에게 시그널을 보내고, 잘못된 경우에는 생산자/소비자가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다

### 읽기 쓰기 (Readers-Writers)
- 읽기 스레드와 쓰기 스레드 사이의 처리율(throughput)을 강조하면 기아(starvation) 현상이 생기거나 오래된 정보가 쌓인다
- 갱신을 허용하면 처리율에 영향을 미친다
- 쓰기 스레드가 버퍼를 갱신하는 동안 읽기 스레드가 버퍼를 읽지 않으려면 (= 마찬가지로 읽기 스레드가 버퍼를 읽는 동안 쓰기 스레드가 버퍼를 갱신하지 않으려면),
    복잡한 균형잡기가 필요
- 대게는 쓰기 스레드가 버퍼를 오랫동안 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어진다

